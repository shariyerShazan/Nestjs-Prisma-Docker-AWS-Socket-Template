
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `PrivateConversation` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model PrivateConversation
 * 
 */
export type PrivateConversationModel = runtime.Types.Result.DefaultSelection<Prisma.$PrivateConversationPayload>

export type AggregatePrivateConversation = {
  _count: PrivateConversationCountAggregateOutputType | null
  _min: PrivateConversationMinAggregateOutputType | null
  _max: PrivateConversationMaxAggregateOutputType | null
}

export type PrivateConversationMinAggregateOutputType = {
  id: string | null
  initiatorId: string | null
  receiverId: string | null
  lastMessageId: string | null
  status: $Enums.ConversationStatus | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type PrivateConversationMaxAggregateOutputType = {
  id: string | null
  initiatorId: string | null
  receiverId: string | null
  lastMessageId: string | null
  status: $Enums.ConversationStatus | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type PrivateConversationCountAggregateOutputType = {
  id: number
  initiatorId: number
  receiverId: number
  lastMessageId: number
  status: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type PrivateConversationMinAggregateInputType = {
  id?: true
  initiatorId?: true
  receiverId?: true
  lastMessageId?: true
  status?: true
  createdAt?: true
  updatedAt?: true
}

export type PrivateConversationMaxAggregateInputType = {
  id?: true
  initiatorId?: true
  receiverId?: true
  lastMessageId?: true
  status?: true
  createdAt?: true
  updatedAt?: true
}

export type PrivateConversationCountAggregateInputType = {
  id?: true
  initiatorId?: true
  receiverId?: true
  lastMessageId?: true
  status?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type PrivateConversationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PrivateConversation to aggregate.
   */
  where?: Prisma.PrivateConversationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PrivateConversations to fetch.
   */
  orderBy?: Prisma.PrivateConversationOrderByWithRelationInput | Prisma.PrivateConversationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.PrivateConversationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PrivateConversations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PrivateConversations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned PrivateConversations
  **/
  _count?: true | PrivateConversationCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: PrivateConversationMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: PrivateConversationMaxAggregateInputType
}

export type GetPrivateConversationAggregateType<T extends PrivateConversationAggregateArgs> = {
      [P in keyof T & keyof AggregatePrivateConversation]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregatePrivateConversation[P]>
    : Prisma.GetScalarType<T[P], AggregatePrivateConversation[P]>
}




export type PrivateConversationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PrivateConversationWhereInput
  orderBy?: Prisma.PrivateConversationOrderByWithAggregationInput | Prisma.PrivateConversationOrderByWithAggregationInput[]
  by: Prisma.PrivateConversationScalarFieldEnum[] | Prisma.PrivateConversationScalarFieldEnum
  having?: Prisma.PrivateConversationScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: PrivateConversationCountAggregateInputType | true
  _min?: PrivateConversationMinAggregateInputType
  _max?: PrivateConversationMaxAggregateInputType
}

export type PrivateConversationGroupByOutputType = {
  id: string
  initiatorId: string
  receiverId: string
  lastMessageId: string | null
  status: $Enums.ConversationStatus
  createdAt: Date
  updatedAt: Date
  _count: PrivateConversationCountAggregateOutputType | null
  _min: PrivateConversationMinAggregateOutputType | null
  _max: PrivateConversationMaxAggregateOutputType | null
}

type GetPrivateConversationGroupByPayload<T extends PrivateConversationGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<PrivateConversationGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof PrivateConversationGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], PrivateConversationGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], PrivateConversationGroupByOutputType[P]>
      }
    >
  >



export type PrivateConversationWhereInput = {
  AND?: Prisma.PrivateConversationWhereInput | Prisma.PrivateConversationWhereInput[]
  OR?: Prisma.PrivateConversationWhereInput[]
  NOT?: Prisma.PrivateConversationWhereInput | Prisma.PrivateConversationWhereInput[]
  id?: Prisma.StringFilter<"PrivateConversation"> | string
  initiatorId?: Prisma.StringFilter<"PrivateConversation"> | string
  receiverId?: Prisma.StringFilter<"PrivateConversation"> | string
  lastMessageId?: Prisma.StringNullableFilter<"PrivateConversation"> | string | null
  status?: Prisma.EnumConversationStatusFilter<"PrivateConversation"> | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFilter<"PrivateConversation"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"PrivateConversation"> | Date | string
  initiator?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  receiver?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  messages?: Prisma.PrivateMessageListRelationFilter
  calls?: Prisma.PrivateCallListRelationFilter
  lastMessage?: Prisma.XOR<Prisma.PrivateMessageNullableScalarRelationFilter, Prisma.PrivateMessageWhereInput> | null
}

export type PrivateConversationOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  initiatorId?: Prisma.SortOrder
  receiverId?: Prisma.SortOrder
  lastMessageId?: Prisma.SortOrderInput | Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  initiator?: Prisma.UserOrderByWithRelationInput
  receiver?: Prisma.UserOrderByWithRelationInput
  messages?: Prisma.PrivateMessageOrderByRelationAggregateInput
  calls?: Prisma.PrivateCallOrderByRelationAggregateInput
  lastMessage?: Prisma.PrivateMessageOrderByWithRelationInput
}

export type PrivateConversationWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  initiatorId_receiverId?: Prisma.PrivateConversationInitiatorIdReceiverIdCompoundUniqueInput
  AND?: Prisma.PrivateConversationWhereInput | Prisma.PrivateConversationWhereInput[]
  OR?: Prisma.PrivateConversationWhereInput[]
  NOT?: Prisma.PrivateConversationWhereInput | Prisma.PrivateConversationWhereInput[]
  initiatorId?: Prisma.StringFilter<"PrivateConversation"> | string
  receiverId?: Prisma.StringFilter<"PrivateConversation"> | string
  lastMessageId?: Prisma.StringNullableFilter<"PrivateConversation"> | string | null
  status?: Prisma.EnumConversationStatusFilter<"PrivateConversation"> | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFilter<"PrivateConversation"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"PrivateConversation"> | Date | string
  initiator?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  receiver?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  messages?: Prisma.PrivateMessageListRelationFilter
  calls?: Prisma.PrivateCallListRelationFilter
  lastMessage?: Prisma.XOR<Prisma.PrivateMessageNullableScalarRelationFilter, Prisma.PrivateMessageWhereInput> | null
}, "id" | "initiatorId_receiverId">

export type PrivateConversationOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  initiatorId?: Prisma.SortOrder
  receiverId?: Prisma.SortOrder
  lastMessageId?: Prisma.SortOrderInput | Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.PrivateConversationCountOrderByAggregateInput
  _max?: Prisma.PrivateConversationMaxOrderByAggregateInput
  _min?: Prisma.PrivateConversationMinOrderByAggregateInput
}

export type PrivateConversationScalarWhereWithAggregatesInput = {
  AND?: Prisma.PrivateConversationScalarWhereWithAggregatesInput | Prisma.PrivateConversationScalarWhereWithAggregatesInput[]
  OR?: Prisma.PrivateConversationScalarWhereWithAggregatesInput[]
  NOT?: Prisma.PrivateConversationScalarWhereWithAggregatesInput | Prisma.PrivateConversationScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"PrivateConversation"> | string
  initiatorId?: Prisma.StringWithAggregatesFilter<"PrivateConversation"> | string
  receiverId?: Prisma.StringWithAggregatesFilter<"PrivateConversation"> | string
  lastMessageId?: Prisma.StringNullableWithAggregatesFilter<"PrivateConversation"> | string | null
  status?: Prisma.EnumConversationStatusWithAggregatesFilter<"PrivateConversation"> | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"PrivateConversation"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"PrivateConversation"> | Date | string
}

export type PrivateConversationCreateInput = {
  id?: string
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  initiator: Prisma.UserCreateNestedOneWithoutConversationsInitiatedInput
  receiver: Prisma.UserCreateNestedOneWithoutConversationsReceivedInput
  messages?: Prisma.PrivateMessageCreateNestedManyWithoutConversationInput
  calls?: Prisma.PrivateCallCreateNestedManyWithoutConversationInput
  lastMessage?: Prisma.PrivateMessageCreateNestedOneWithoutPrivateLastMessageInput
}

export type PrivateConversationUncheckedCreateInput = {
  id?: string
  initiatorId: string
  receiverId: string
  lastMessageId?: string | null
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  messages?: Prisma.PrivateMessageUncheckedCreateNestedManyWithoutConversationInput
  calls?: Prisma.PrivateCallUncheckedCreateNestedManyWithoutConversationInput
}

export type PrivateConversationUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  initiator?: Prisma.UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
  receiver?: Prisma.UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
  messages?: Prisma.PrivateMessageUpdateManyWithoutConversationNestedInput
  calls?: Prisma.PrivateCallUpdateManyWithoutConversationNestedInput
  lastMessage?: Prisma.PrivateMessageUpdateOneWithoutPrivateLastMessageNestedInput
}

export type PrivateConversationUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  initiatorId?: Prisma.StringFieldUpdateOperationsInput | string
  receiverId?: Prisma.StringFieldUpdateOperationsInput | string
  lastMessageId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  messages?: Prisma.PrivateMessageUncheckedUpdateManyWithoutConversationNestedInput
  calls?: Prisma.PrivateCallUncheckedUpdateManyWithoutConversationNestedInput
}

export type PrivateConversationCreateManyInput = {
  id?: string
  initiatorId: string
  receiverId: string
  lastMessageId?: string | null
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type PrivateConversationUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PrivateConversationUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  initiatorId?: Prisma.StringFieldUpdateOperationsInput | string
  receiverId?: Prisma.StringFieldUpdateOperationsInput | string
  lastMessageId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PrivateConversationScalarRelationFilter = {
  is?: Prisma.PrivateConversationWhereInput
  isNot?: Prisma.PrivateConversationWhereInput
}

export type PrivateConversationInitiatorIdReceiverIdCompoundUniqueInput = {
  initiatorId: string
  receiverId: string
}

export type PrivateConversationCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  initiatorId?: Prisma.SortOrder
  receiverId?: Prisma.SortOrder
  lastMessageId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type PrivateConversationMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  initiatorId?: Prisma.SortOrder
  receiverId?: Prisma.SortOrder
  lastMessageId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type PrivateConversationMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  initiatorId?: Prisma.SortOrder
  receiverId?: Prisma.SortOrder
  lastMessageId?: Prisma.SortOrder
  status?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type PrivateConversationListRelationFilter = {
  every?: Prisma.PrivateConversationWhereInput
  some?: Prisma.PrivateConversationWhereInput
  none?: Prisma.PrivateConversationWhereInput
}

export type PrivateConversationOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type PrivateConversationCreateNestedOneWithoutCallsInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutCallsInput, Prisma.PrivateConversationUncheckedCreateWithoutCallsInput>
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutCallsInput
  connect?: Prisma.PrivateConversationWhereUniqueInput
}

export type PrivateConversationUpdateOneRequiredWithoutCallsNestedInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutCallsInput, Prisma.PrivateConversationUncheckedCreateWithoutCallsInput>
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutCallsInput
  upsert?: Prisma.PrivateConversationUpsertWithoutCallsInput
  connect?: Prisma.PrivateConversationWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PrivateConversationUpdateToOneWithWhereWithoutCallsInput, Prisma.PrivateConversationUpdateWithoutCallsInput>, Prisma.PrivateConversationUncheckedUpdateWithoutCallsInput>
}

export type EnumConversationStatusFieldUpdateOperationsInput = {
  set?: $Enums.ConversationStatus
}

export type PrivateConversationCreateNestedOneWithoutMessagesInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutMessagesInput, Prisma.PrivateConversationUncheckedCreateWithoutMessagesInput>
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutMessagesInput
  connect?: Prisma.PrivateConversationWhereUniqueInput
}

export type PrivateConversationCreateNestedManyWithoutLastMessageInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutLastMessageInput, Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput> | Prisma.PrivateConversationCreateWithoutLastMessageInput[] | Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutLastMessageInput | Prisma.PrivateConversationCreateOrConnectWithoutLastMessageInput[]
  createMany?: Prisma.PrivateConversationCreateManyLastMessageInputEnvelope
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
}

export type PrivateConversationUncheckedCreateNestedManyWithoutLastMessageInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutLastMessageInput, Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput> | Prisma.PrivateConversationCreateWithoutLastMessageInput[] | Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutLastMessageInput | Prisma.PrivateConversationCreateOrConnectWithoutLastMessageInput[]
  createMany?: Prisma.PrivateConversationCreateManyLastMessageInputEnvelope
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
}

export type PrivateConversationUpdateOneRequiredWithoutMessagesNestedInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutMessagesInput, Prisma.PrivateConversationUncheckedCreateWithoutMessagesInput>
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutMessagesInput
  upsert?: Prisma.PrivateConversationUpsertWithoutMessagesInput
  connect?: Prisma.PrivateConversationWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PrivateConversationUpdateToOneWithWhereWithoutMessagesInput, Prisma.PrivateConversationUpdateWithoutMessagesInput>, Prisma.PrivateConversationUncheckedUpdateWithoutMessagesInput>
}

export type PrivateConversationUpdateManyWithoutLastMessageNestedInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutLastMessageInput, Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput> | Prisma.PrivateConversationCreateWithoutLastMessageInput[] | Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutLastMessageInput | Prisma.PrivateConversationCreateOrConnectWithoutLastMessageInput[]
  upsert?: Prisma.PrivateConversationUpsertWithWhereUniqueWithoutLastMessageInput | Prisma.PrivateConversationUpsertWithWhereUniqueWithoutLastMessageInput[]
  createMany?: Prisma.PrivateConversationCreateManyLastMessageInputEnvelope
  set?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  disconnect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  delete?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  update?: Prisma.PrivateConversationUpdateWithWhereUniqueWithoutLastMessageInput | Prisma.PrivateConversationUpdateWithWhereUniqueWithoutLastMessageInput[]
  updateMany?: Prisma.PrivateConversationUpdateManyWithWhereWithoutLastMessageInput | Prisma.PrivateConversationUpdateManyWithWhereWithoutLastMessageInput[]
  deleteMany?: Prisma.PrivateConversationScalarWhereInput | Prisma.PrivateConversationScalarWhereInput[]
}

export type PrivateConversationUncheckedUpdateManyWithoutLastMessageNestedInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutLastMessageInput, Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput> | Prisma.PrivateConversationCreateWithoutLastMessageInput[] | Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutLastMessageInput | Prisma.PrivateConversationCreateOrConnectWithoutLastMessageInput[]
  upsert?: Prisma.PrivateConversationUpsertWithWhereUniqueWithoutLastMessageInput | Prisma.PrivateConversationUpsertWithWhereUniqueWithoutLastMessageInput[]
  createMany?: Prisma.PrivateConversationCreateManyLastMessageInputEnvelope
  set?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  disconnect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  delete?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  update?: Prisma.PrivateConversationUpdateWithWhereUniqueWithoutLastMessageInput | Prisma.PrivateConversationUpdateWithWhereUniqueWithoutLastMessageInput[]
  updateMany?: Prisma.PrivateConversationUpdateManyWithWhereWithoutLastMessageInput | Prisma.PrivateConversationUpdateManyWithWhereWithoutLastMessageInput[]
  deleteMany?: Prisma.PrivateConversationScalarWhereInput | Prisma.PrivateConversationScalarWhereInput[]
}

export type PrivateConversationCreateNestedManyWithoutInitiatorInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutInitiatorInput, Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput> | Prisma.PrivateConversationCreateWithoutInitiatorInput[] | Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutInitiatorInput | Prisma.PrivateConversationCreateOrConnectWithoutInitiatorInput[]
  createMany?: Prisma.PrivateConversationCreateManyInitiatorInputEnvelope
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
}

export type PrivateConversationCreateNestedManyWithoutReceiverInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutReceiverInput, Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput> | Prisma.PrivateConversationCreateWithoutReceiverInput[] | Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutReceiverInput | Prisma.PrivateConversationCreateOrConnectWithoutReceiverInput[]
  createMany?: Prisma.PrivateConversationCreateManyReceiverInputEnvelope
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
}

export type PrivateConversationUncheckedCreateNestedManyWithoutInitiatorInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutInitiatorInput, Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput> | Prisma.PrivateConversationCreateWithoutInitiatorInput[] | Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutInitiatorInput | Prisma.PrivateConversationCreateOrConnectWithoutInitiatorInput[]
  createMany?: Prisma.PrivateConversationCreateManyInitiatorInputEnvelope
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
}

export type PrivateConversationUncheckedCreateNestedManyWithoutReceiverInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutReceiverInput, Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput> | Prisma.PrivateConversationCreateWithoutReceiverInput[] | Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutReceiverInput | Prisma.PrivateConversationCreateOrConnectWithoutReceiverInput[]
  createMany?: Prisma.PrivateConversationCreateManyReceiverInputEnvelope
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
}

export type PrivateConversationUpdateManyWithoutInitiatorNestedInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutInitiatorInput, Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput> | Prisma.PrivateConversationCreateWithoutInitiatorInput[] | Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutInitiatorInput | Prisma.PrivateConversationCreateOrConnectWithoutInitiatorInput[]
  upsert?: Prisma.PrivateConversationUpsertWithWhereUniqueWithoutInitiatorInput | Prisma.PrivateConversationUpsertWithWhereUniqueWithoutInitiatorInput[]
  createMany?: Prisma.PrivateConversationCreateManyInitiatorInputEnvelope
  set?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  disconnect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  delete?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  update?: Prisma.PrivateConversationUpdateWithWhereUniqueWithoutInitiatorInput | Prisma.PrivateConversationUpdateWithWhereUniqueWithoutInitiatorInput[]
  updateMany?: Prisma.PrivateConversationUpdateManyWithWhereWithoutInitiatorInput | Prisma.PrivateConversationUpdateManyWithWhereWithoutInitiatorInput[]
  deleteMany?: Prisma.PrivateConversationScalarWhereInput | Prisma.PrivateConversationScalarWhereInput[]
}

export type PrivateConversationUpdateManyWithoutReceiverNestedInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutReceiverInput, Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput> | Prisma.PrivateConversationCreateWithoutReceiverInput[] | Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutReceiverInput | Prisma.PrivateConversationCreateOrConnectWithoutReceiverInput[]
  upsert?: Prisma.PrivateConversationUpsertWithWhereUniqueWithoutReceiverInput | Prisma.PrivateConversationUpsertWithWhereUniqueWithoutReceiverInput[]
  createMany?: Prisma.PrivateConversationCreateManyReceiverInputEnvelope
  set?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  disconnect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  delete?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  update?: Prisma.PrivateConversationUpdateWithWhereUniqueWithoutReceiverInput | Prisma.PrivateConversationUpdateWithWhereUniqueWithoutReceiverInput[]
  updateMany?: Prisma.PrivateConversationUpdateManyWithWhereWithoutReceiverInput | Prisma.PrivateConversationUpdateManyWithWhereWithoutReceiverInput[]
  deleteMany?: Prisma.PrivateConversationScalarWhereInput | Prisma.PrivateConversationScalarWhereInput[]
}

export type PrivateConversationUncheckedUpdateManyWithoutInitiatorNestedInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutInitiatorInput, Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput> | Prisma.PrivateConversationCreateWithoutInitiatorInput[] | Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutInitiatorInput | Prisma.PrivateConversationCreateOrConnectWithoutInitiatorInput[]
  upsert?: Prisma.PrivateConversationUpsertWithWhereUniqueWithoutInitiatorInput | Prisma.PrivateConversationUpsertWithWhereUniqueWithoutInitiatorInput[]
  createMany?: Prisma.PrivateConversationCreateManyInitiatorInputEnvelope
  set?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  disconnect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  delete?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  update?: Prisma.PrivateConversationUpdateWithWhereUniqueWithoutInitiatorInput | Prisma.PrivateConversationUpdateWithWhereUniqueWithoutInitiatorInput[]
  updateMany?: Prisma.PrivateConversationUpdateManyWithWhereWithoutInitiatorInput | Prisma.PrivateConversationUpdateManyWithWhereWithoutInitiatorInput[]
  deleteMany?: Prisma.PrivateConversationScalarWhereInput | Prisma.PrivateConversationScalarWhereInput[]
}

export type PrivateConversationUncheckedUpdateManyWithoutReceiverNestedInput = {
  create?: Prisma.XOR<Prisma.PrivateConversationCreateWithoutReceiverInput, Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput> | Prisma.PrivateConversationCreateWithoutReceiverInput[] | Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput[]
  connectOrCreate?: Prisma.PrivateConversationCreateOrConnectWithoutReceiverInput | Prisma.PrivateConversationCreateOrConnectWithoutReceiverInput[]
  upsert?: Prisma.PrivateConversationUpsertWithWhereUniqueWithoutReceiverInput | Prisma.PrivateConversationUpsertWithWhereUniqueWithoutReceiverInput[]
  createMany?: Prisma.PrivateConversationCreateManyReceiverInputEnvelope
  set?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  disconnect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  delete?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  connect?: Prisma.PrivateConversationWhereUniqueInput | Prisma.PrivateConversationWhereUniqueInput[]
  update?: Prisma.PrivateConversationUpdateWithWhereUniqueWithoutReceiverInput | Prisma.PrivateConversationUpdateWithWhereUniqueWithoutReceiverInput[]
  updateMany?: Prisma.PrivateConversationUpdateManyWithWhereWithoutReceiverInput | Prisma.PrivateConversationUpdateManyWithWhereWithoutReceiverInput[]
  deleteMany?: Prisma.PrivateConversationScalarWhereInput | Prisma.PrivateConversationScalarWhereInput[]
}

export type PrivateConversationCreateWithoutCallsInput = {
  id?: string
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  initiator: Prisma.UserCreateNestedOneWithoutConversationsInitiatedInput
  receiver: Prisma.UserCreateNestedOneWithoutConversationsReceivedInput
  messages?: Prisma.PrivateMessageCreateNestedManyWithoutConversationInput
  lastMessage?: Prisma.PrivateMessageCreateNestedOneWithoutPrivateLastMessageInput
}

export type PrivateConversationUncheckedCreateWithoutCallsInput = {
  id?: string
  initiatorId: string
  receiverId: string
  lastMessageId?: string | null
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  messages?: Prisma.PrivateMessageUncheckedCreateNestedManyWithoutConversationInput
}

export type PrivateConversationCreateOrConnectWithoutCallsInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutCallsInput, Prisma.PrivateConversationUncheckedCreateWithoutCallsInput>
}

export type PrivateConversationUpsertWithoutCallsInput = {
  update: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutCallsInput, Prisma.PrivateConversationUncheckedUpdateWithoutCallsInput>
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutCallsInput, Prisma.PrivateConversationUncheckedCreateWithoutCallsInput>
  where?: Prisma.PrivateConversationWhereInput
}

export type PrivateConversationUpdateToOneWithWhereWithoutCallsInput = {
  where?: Prisma.PrivateConversationWhereInput
  data: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutCallsInput, Prisma.PrivateConversationUncheckedUpdateWithoutCallsInput>
}

export type PrivateConversationUpdateWithoutCallsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  initiator?: Prisma.UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
  receiver?: Prisma.UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
  messages?: Prisma.PrivateMessageUpdateManyWithoutConversationNestedInput
  lastMessage?: Prisma.PrivateMessageUpdateOneWithoutPrivateLastMessageNestedInput
}

export type PrivateConversationUncheckedUpdateWithoutCallsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  initiatorId?: Prisma.StringFieldUpdateOperationsInput | string
  receiverId?: Prisma.StringFieldUpdateOperationsInput | string
  lastMessageId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  messages?: Prisma.PrivateMessageUncheckedUpdateManyWithoutConversationNestedInput
}

export type PrivateConversationCreateWithoutMessagesInput = {
  id?: string
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  initiator: Prisma.UserCreateNestedOneWithoutConversationsInitiatedInput
  receiver: Prisma.UserCreateNestedOneWithoutConversationsReceivedInput
  calls?: Prisma.PrivateCallCreateNestedManyWithoutConversationInput
  lastMessage?: Prisma.PrivateMessageCreateNestedOneWithoutPrivateLastMessageInput
}

export type PrivateConversationUncheckedCreateWithoutMessagesInput = {
  id?: string
  initiatorId: string
  receiverId: string
  lastMessageId?: string | null
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  calls?: Prisma.PrivateCallUncheckedCreateNestedManyWithoutConversationInput
}

export type PrivateConversationCreateOrConnectWithoutMessagesInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutMessagesInput, Prisma.PrivateConversationUncheckedCreateWithoutMessagesInput>
}

export type PrivateConversationCreateWithoutLastMessageInput = {
  id?: string
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  initiator: Prisma.UserCreateNestedOneWithoutConversationsInitiatedInput
  receiver: Prisma.UserCreateNestedOneWithoutConversationsReceivedInput
  messages?: Prisma.PrivateMessageCreateNestedManyWithoutConversationInput
  calls?: Prisma.PrivateCallCreateNestedManyWithoutConversationInput
}

export type PrivateConversationUncheckedCreateWithoutLastMessageInput = {
  id?: string
  initiatorId: string
  receiverId: string
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  messages?: Prisma.PrivateMessageUncheckedCreateNestedManyWithoutConversationInput
  calls?: Prisma.PrivateCallUncheckedCreateNestedManyWithoutConversationInput
}

export type PrivateConversationCreateOrConnectWithoutLastMessageInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutLastMessageInput, Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput>
}

export type PrivateConversationCreateManyLastMessageInputEnvelope = {
  data: Prisma.PrivateConversationCreateManyLastMessageInput | Prisma.PrivateConversationCreateManyLastMessageInput[]
  skipDuplicates?: boolean
}

export type PrivateConversationUpsertWithoutMessagesInput = {
  update: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutMessagesInput, Prisma.PrivateConversationUncheckedUpdateWithoutMessagesInput>
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutMessagesInput, Prisma.PrivateConversationUncheckedCreateWithoutMessagesInput>
  where?: Prisma.PrivateConversationWhereInput
}

export type PrivateConversationUpdateToOneWithWhereWithoutMessagesInput = {
  where?: Prisma.PrivateConversationWhereInput
  data: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutMessagesInput, Prisma.PrivateConversationUncheckedUpdateWithoutMessagesInput>
}

export type PrivateConversationUpdateWithoutMessagesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  initiator?: Prisma.UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
  receiver?: Prisma.UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
  calls?: Prisma.PrivateCallUpdateManyWithoutConversationNestedInput
  lastMessage?: Prisma.PrivateMessageUpdateOneWithoutPrivateLastMessageNestedInput
}

export type PrivateConversationUncheckedUpdateWithoutMessagesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  initiatorId?: Prisma.StringFieldUpdateOperationsInput | string
  receiverId?: Prisma.StringFieldUpdateOperationsInput | string
  lastMessageId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  calls?: Prisma.PrivateCallUncheckedUpdateManyWithoutConversationNestedInput
}

export type PrivateConversationUpsertWithWhereUniqueWithoutLastMessageInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  update: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutLastMessageInput, Prisma.PrivateConversationUncheckedUpdateWithoutLastMessageInput>
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutLastMessageInput, Prisma.PrivateConversationUncheckedCreateWithoutLastMessageInput>
}

export type PrivateConversationUpdateWithWhereUniqueWithoutLastMessageInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  data: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutLastMessageInput, Prisma.PrivateConversationUncheckedUpdateWithoutLastMessageInput>
}

export type PrivateConversationUpdateManyWithWhereWithoutLastMessageInput = {
  where: Prisma.PrivateConversationScalarWhereInput
  data: Prisma.XOR<Prisma.PrivateConversationUpdateManyMutationInput, Prisma.PrivateConversationUncheckedUpdateManyWithoutLastMessageInput>
}

export type PrivateConversationScalarWhereInput = {
  AND?: Prisma.PrivateConversationScalarWhereInput | Prisma.PrivateConversationScalarWhereInput[]
  OR?: Prisma.PrivateConversationScalarWhereInput[]
  NOT?: Prisma.PrivateConversationScalarWhereInput | Prisma.PrivateConversationScalarWhereInput[]
  id?: Prisma.StringFilter<"PrivateConversation"> | string
  initiatorId?: Prisma.StringFilter<"PrivateConversation"> | string
  receiverId?: Prisma.StringFilter<"PrivateConversation"> | string
  lastMessageId?: Prisma.StringNullableFilter<"PrivateConversation"> | string | null
  status?: Prisma.EnumConversationStatusFilter<"PrivateConversation"> | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFilter<"PrivateConversation"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"PrivateConversation"> | Date | string
}

export type PrivateConversationCreateWithoutInitiatorInput = {
  id?: string
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  receiver: Prisma.UserCreateNestedOneWithoutConversationsReceivedInput
  messages?: Prisma.PrivateMessageCreateNestedManyWithoutConversationInput
  calls?: Prisma.PrivateCallCreateNestedManyWithoutConversationInput
  lastMessage?: Prisma.PrivateMessageCreateNestedOneWithoutPrivateLastMessageInput
}

export type PrivateConversationUncheckedCreateWithoutInitiatorInput = {
  id?: string
  receiverId: string
  lastMessageId?: string | null
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  messages?: Prisma.PrivateMessageUncheckedCreateNestedManyWithoutConversationInput
  calls?: Prisma.PrivateCallUncheckedCreateNestedManyWithoutConversationInput
}

export type PrivateConversationCreateOrConnectWithoutInitiatorInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutInitiatorInput, Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput>
}

export type PrivateConversationCreateManyInitiatorInputEnvelope = {
  data: Prisma.PrivateConversationCreateManyInitiatorInput | Prisma.PrivateConversationCreateManyInitiatorInput[]
  skipDuplicates?: boolean
}

export type PrivateConversationCreateWithoutReceiverInput = {
  id?: string
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  initiator: Prisma.UserCreateNestedOneWithoutConversationsInitiatedInput
  messages?: Prisma.PrivateMessageCreateNestedManyWithoutConversationInput
  calls?: Prisma.PrivateCallCreateNestedManyWithoutConversationInput
  lastMessage?: Prisma.PrivateMessageCreateNestedOneWithoutPrivateLastMessageInput
}

export type PrivateConversationUncheckedCreateWithoutReceiverInput = {
  id?: string
  initiatorId: string
  lastMessageId?: string | null
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
  messages?: Prisma.PrivateMessageUncheckedCreateNestedManyWithoutConversationInput
  calls?: Prisma.PrivateCallUncheckedCreateNestedManyWithoutConversationInput
}

export type PrivateConversationCreateOrConnectWithoutReceiverInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutReceiverInput, Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput>
}

export type PrivateConversationCreateManyReceiverInputEnvelope = {
  data: Prisma.PrivateConversationCreateManyReceiverInput | Prisma.PrivateConversationCreateManyReceiverInput[]
  skipDuplicates?: boolean
}

export type PrivateConversationUpsertWithWhereUniqueWithoutInitiatorInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  update: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutInitiatorInput, Prisma.PrivateConversationUncheckedUpdateWithoutInitiatorInput>
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutInitiatorInput, Prisma.PrivateConversationUncheckedCreateWithoutInitiatorInput>
}

export type PrivateConversationUpdateWithWhereUniqueWithoutInitiatorInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  data: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutInitiatorInput, Prisma.PrivateConversationUncheckedUpdateWithoutInitiatorInput>
}

export type PrivateConversationUpdateManyWithWhereWithoutInitiatorInput = {
  where: Prisma.PrivateConversationScalarWhereInput
  data: Prisma.XOR<Prisma.PrivateConversationUpdateManyMutationInput, Prisma.PrivateConversationUncheckedUpdateManyWithoutInitiatorInput>
}

export type PrivateConversationUpsertWithWhereUniqueWithoutReceiverInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  update: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutReceiverInput, Prisma.PrivateConversationUncheckedUpdateWithoutReceiverInput>
  create: Prisma.XOR<Prisma.PrivateConversationCreateWithoutReceiverInput, Prisma.PrivateConversationUncheckedCreateWithoutReceiverInput>
}

export type PrivateConversationUpdateWithWhereUniqueWithoutReceiverInput = {
  where: Prisma.PrivateConversationWhereUniqueInput
  data: Prisma.XOR<Prisma.PrivateConversationUpdateWithoutReceiverInput, Prisma.PrivateConversationUncheckedUpdateWithoutReceiverInput>
}

export type PrivateConversationUpdateManyWithWhereWithoutReceiverInput = {
  where: Prisma.PrivateConversationScalarWhereInput
  data: Prisma.XOR<Prisma.PrivateConversationUpdateManyMutationInput, Prisma.PrivateConversationUncheckedUpdateManyWithoutReceiverInput>
}

export type PrivateConversationCreateManyLastMessageInput = {
  id?: string
  initiatorId: string
  receiverId: string
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type PrivateConversationUpdateWithoutLastMessageInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  initiator?: Prisma.UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
  receiver?: Prisma.UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
  messages?: Prisma.PrivateMessageUpdateManyWithoutConversationNestedInput
  calls?: Prisma.PrivateCallUpdateManyWithoutConversationNestedInput
}

export type PrivateConversationUncheckedUpdateWithoutLastMessageInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  initiatorId?: Prisma.StringFieldUpdateOperationsInput | string
  receiverId?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  messages?: Prisma.PrivateMessageUncheckedUpdateManyWithoutConversationNestedInput
  calls?: Prisma.PrivateCallUncheckedUpdateManyWithoutConversationNestedInput
}

export type PrivateConversationUncheckedUpdateManyWithoutLastMessageInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  initiatorId?: Prisma.StringFieldUpdateOperationsInput | string
  receiverId?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PrivateConversationCreateManyInitiatorInput = {
  id?: string
  receiverId: string
  lastMessageId?: string | null
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type PrivateConversationCreateManyReceiverInput = {
  id?: string
  initiatorId: string
  lastMessageId?: string | null
  status?: $Enums.ConversationStatus
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type PrivateConversationUpdateWithoutInitiatorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  receiver?: Prisma.UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
  messages?: Prisma.PrivateMessageUpdateManyWithoutConversationNestedInput
  calls?: Prisma.PrivateCallUpdateManyWithoutConversationNestedInput
  lastMessage?: Prisma.PrivateMessageUpdateOneWithoutPrivateLastMessageNestedInput
}

export type PrivateConversationUncheckedUpdateWithoutInitiatorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  receiverId?: Prisma.StringFieldUpdateOperationsInput | string
  lastMessageId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  messages?: Prisma.PrivateMessageUncheckedUpdateManyWithoutConversationNestedInput
  calls?: Prisma.PrivateCallUncheckedUpdateManyWithoutConversationNestedInput
}

export type PrivateConversationUncheckedUpdateManyWithoutInitiatorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  receiverId?: Prisma.StringFieldUpdateOperationsInput | string
  lastMessageId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PrivateConversationUpdateWithoutReceiverInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  initiator?: Prisma.UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
  messages?: Prisma.PrivateMessageUpdateManyWithoutConversationNestedInput
  calls?: Prisma.PrivateCallUpdateManyWithoutConversationNestedInput
  lastMessage?: Prisma.PrivateMessageUpdateOneWithoutPrivateLastMessageNestedInput
}

export type PrivateConversationUncheckedUpdateWithoutReceiverInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  initiatorId?: Prisma.StringFieldUpdateOperationsInput | string
  lastMessageId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  messages?: Prisma.PrivateMessageUncheckedUpdateManyWithoutConversationNestedInput
  calls?: Prisma.PrivateCallUncheckedUpdateManyWithoutConversationNestedInput
}

export type PrivateConversationUncheckedUpdateManyWithoutReceiverInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  initiatorId?: Prisma.StringFieldUpdateOperationsInput | string
  lastMessageId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  status?: Prisma.EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}


/**
 * Count Type PrivateConversationCountOutputType
 */

export type PrivateConversationCountOutputType = {
  messages: number
  calls: number
}

export type PrivateConversationCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  messages?: boolean | PrivateConversationCountOutputTypeCountMessagesArgs
  calls?: boolean | PrivateConversationCountOutputTypeCountCallsArgs
}

/**
 * PrivateConversationCountOutputType without action
 */
export type PrivateConversationCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversationCountOutputType
   */
  select?: Prisma.PrivateConversationCountOutputTypeSelect<ExtArgs> | null
}

/**
 * PrivateConversationCountOutputType without action
 */
export type PrivateConversationCountOutputTypeCountMessagesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PrivateMessageWhereInput
}

/**
 * PrivateConversationCountOutputType without action
 */
export type PrivateConversationCountOutputTypeCountCallsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PrivateCallWhereInput
}


export type PrivateConversationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  initiatorId?: boolean
  receiverId?: boolean
  lastMessageId?: boolean
  status?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  initiator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  receiver?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  messages?: boolean | Prisma.PrivateConversation$messagesArgs<ExtArgs>
  calls?: boolean | Prisma.PrivateConversation$callsArgs<ExtArgs>
  lastMessage?: boolean | Prisma.PrivateConversation$lastMessageArgs<ExtArgs>
  _count?: boolean | Prisma.PrivateConversationCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["privateConversation"]>

export type PrivateConversationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  initiatorId?: boolean
  receiverId?: boolean
  lastMessageId?: boolean
  status?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  initiator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  receiver?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  lastMessage?: boolean | Prisma.PrivateConversation$lastMessageArgs<ExtArgs>
}, ExtArgs["result"]["privateConversation"]>

export type PrivateConversationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  initiatorId?: boolean
  receiverId?: boolean
  lastMessageId?: boolean
  status?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  initiator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  receiver?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  lastMessage?: boolean | Prisma.PrivateConversation$lastMessageArgs<ExtArgs>
}, ExtArgs["result"]["privateConversation"]>

export type PrivateConversationSelectScalar = {
  id?: boolean
  initiatorId?: boolean
  receiverId?: boolean
  lastMessageId?: boolean
  status?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type PrivateConversationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "initiatorId" | "receiverId" | "lastMessageId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["privateConversation"]>
export type PrivateConversationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  initiator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  receiver?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  messages?: boolean | Prisma.PrivateConversation$messagesArgs<ExtArgs>
  calls?: boolean | Prisma.PrivateConversation$callsArgs<ExtArgs>
  lastMessage?: boolean | Prisma.PrivateConversation$lastMessageArgs<ExtArgs>
  _count?: boolean | Prisma.PrivateConversationCountOutputTypeDefaultArgs<ExtArgs>
}
export type PrivateConversationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  initiator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  receiver?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  lastMessage?: boolean | Prisma.PrivateConversation$lastMessageArgs<ExtArgs>
}
export type PrivateConversationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  initiator?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  receiver?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  lastMessage?: boolean | Prisma.PrivateConversation$lastMessageArgs<ExtArgs>
}

export type $PrivateConversationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "PrivateConversation"
  objects: {
    initiator: Prisma.$UserPayload<ExtArgs>
    receiver: Prisma.$UserPayload<ExtArgs>
    messages: Prisma.$PrivateMessagePayload<ExtArgs>[]
    calls: Prisma.$PrivateCallPayload<ExtArgs>[]
    lastMessage: Prisma.$PrivateMessagePayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    /**
     * User who initiated the conversation
     */
    initiatorId: string
    /**
     * User who received the conversation
     */
    receiverId: string
    lastMessageId: string | null
    status: $Enums.ConversationStatus
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["privateConversation"]>
  composites: {}
}

export type PrivateConversationGetPayload<S extends boolean | null | undefined | PrivateConversationDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload, S>

export type PrivateConversationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<PrivateConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PrivateConversationCountAggregateInputType | true
  }

export interface PrivateConversationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateConversation'], meta: { name: 'PrivateConversation' } }
  /**
   * Find zero or one PrivateConversation that matches the filter.
   * @param {PrivateConversationFindUniqueArgs} args - Arguments to find a PrivateConversation
   * @example
   * // Get one PrivateConversation
   * const privateConversation = await prisma.privateConversation.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends PrivateConversationFindUniqueArgs>(args: Prisma.SelectSubset<T, PrivateConversationFindUniqueArgs<ExtArgs>>): Prisma.Prisma__PrivateConversationClient<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one PrivateConversation that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {PrivateConversationFindUniqueOrThrowArgs} args - Arguments to find a PrivateConversation
   * @example
   * // Get one PrivateConversation
   * const privateConversation = await prisma.privateConversation.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends PrivateConversationFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, PrivateConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__PrivateConversationClient<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PrivateConversation that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrivateConversationFindFirstArgs} args - Arguments to find a PrivateConversation
   * @example
   * // Get one PrivateConversation
   * const privateConversation = await prisma.privateConversation.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends PrivateConversationFindFirstArgs>(args?: Prisma.SelectSubset<T, PrivateConversationFindFirstArgs<ExtArgs>>): Prisma.Prisma__PrivateConversationClient<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PrivateConversation that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrivateConversationFindFirstOrThrowArgs} args - Arguments to find a PrivateConversation
   * @example
   * // Get one PrivateConversation
   * const privateConversation = await prisma.privateConversation.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends PrivateConversationFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, PrivateConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__PrivateConversationClient<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more PrivateConversations that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrivateConversationFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all PrivateConversations
   * const privateConversations = await prisma.privateConversation.findMany()
   * 
   * // Get first 10 PrivateConversations
   * const privateConversations = await prisma.privateConversation.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const privateConversationWithIdOnly = await prisma.privateConversation.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends PrivateConversationFindManyArgs>(args?: Prisma.SelectSubset<T, PrivateConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a PrivateConversation.
   * @param {PrivateConversationCreateArgs} args - Arguments to create a PrivateConversation.
   * @example
   * // Create one PrivateConversation
   * const PrivateConversation = await prisma.privateConversation.create({
   *   data: {
   *     // ... data to create a PrivateConversation
   *   }
   * })
   * 
   */
  create<T extends PrivateConversationCreateArgs>(args: Prisma.SelectSubset<T, PrivateConversationCreateArgs<ExtArgs>>): Prisma.Prisma__PrivateConversationClient<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many PrivateConversations.
   * @param {PrivateConversationCreateManyArgs} args - Arguments to create many PrivateConversations.
   * @example
   * // Create many PrivateConversations
   * const privateConversation = await prisma.privateConversation.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends PrivateConversationCreateManyArgs>(args?: Prisma.SelectSubset<T, PrivateConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many PrivateConversations and returns the data saved in the database.
   * @param {PrivateConversationCreateManyAndReturnArgs} args - Arguments to create many PrivateConversations.
   * @example
   * // Create many PrivateConversations
   * const privateConversation = await prisma.privateConversation.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many PrivateConversations and only return the `id`
   * const privateConversationWithIdOnly = await prisma.privateConversation.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends PrivateConversationCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, PrivateConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a PrivateConversation.
   * @param {PrivateConversationDeleteArgs} args - Arguments to delete one PrivateConversation.
   * @example
   * // Delete one PrivateConversation
   * const PrivateConversation = await prisma.privateConversation.delete({
   *   where: {
   *     // ... filter to delete one PrivateConversation
   *   }
   * })
   * 
   */
  delete<T extends PrivateConversationDeleteArgs>(args: Prisma.SelectSubset<T, PrivateConversationDeleteArgs<ExtArgs>>): Prisma.Prisma__PrivateConversationClient<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one PrivateConversation.
   * @param {PrivateConversationUpdateArgs} args - Arguments to update one PrivateConversation.
   * @example
   * // Update one PrivateConversation
   * const privateConversation = await prisma.privateConversation.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends PrivateConversationUpdateArgs>(args: Prisma.SelectSubset<T, PrivateConversationUpdateArgs<ExtArgs>>): Prisma.Prisma__PrivateConversationClient<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more PrivateConversations.
   * @param {PrivateConversationDeleteManyArgs} args - Arguments to filter PrivateConversations to delete.
   * @example
   * // Delete a few PrivateConversations
   * const { count } = await prisma.privateConversation.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends PrivateConversationDeleteManyArgs>(args?: Prisma.SelectSubset<T, PrivateConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PrivateConversations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrivateConversationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many PrivateConversations
   * const privateConversation = await prisma.privateConversation.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends PrivateConversationUpdateManyArgs>(args: Prisma.SelectSubset<T, PrivateConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PrivateConversations and returns the data updated in the database.
   * @param {PrivateConversationUpdateManyAndReturnArgs} args - Arguments to update many PrivateConversations.
   * @example
   * // Update many PrivateConversations
   * const privateConversation = await prisma.privateConversation.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more PrivateConversations and only return the `id`
   * const privateConversationWithIdOnly = await prisma.privateConversation.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends PrivateConversationUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, PrivateConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one PrivateConversation.
   * @param {PrivateConversationUpsertArgs} args - Arguments to update or create a PrivateConversation.
   * @example
   * // Update or create a PrivateConversation
   * const privateConversation = await prisma.privateConversation.upsert({
   *   create: {
   *     // ... data to create a PrivateConversation
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the PrivateConversation we want to update
   *   }
   * })
   */
  upsert<T extends PrivateConversationUpsertArgs>(args: Prisma.SelectSubset<T, PrivateConversationUpsertArgs<ExtArgs>>): Prisma.Prisma__PrivateConversationClient<runtime.Types.Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of PrivateConversations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrivateConversationCountArgs} args - Arguments to filter PrivateConversations to count.
   * @example
   * // Count the number of PrivateConversations
   * const count = await prisma.privateConversation.count({
   *   where: {
   *     // ... the filter for the PrivateConversations we want to count
   *   }
   * })
  **/
  count<T extends PrivateConversationCountArgs>(
    args?: Prisma.Subset<T, PrivateConversationCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], PrivateConversationCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a PrivateConversation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrivateConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends PrivateConversationAggregateArgs>(args: Prisma.Subset<T, PrivateConversationAggregateArgs>): Prisma.PrismaPromise<GetPrivateConversationAggregateType<T>>

  /**
   * Group by PrivateConversation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PrivateConversationGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends PrivateConversationGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: PrivateConversationGroupByArgs['orderBy'] }
      : { orderBy?: PrivateConversationGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, PrivateConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the PrivateConversation model
 */
readonly fields: PrivateConversationFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for PrivateConversation.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PrivateConversationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  initiator<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  receiver<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  messages<T extends Prisma.PrivateConversation$messagesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PrivateConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  calls<T extends Prisma.PrivateConversation$callsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PrivateConversation$callsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PrivateCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  lastMessage<T extends Prisma.PrivateConversation$lastMessageArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PrivateConversation$lastMessageArgs<ExtArgs>>): Prisma.Prisma__PrivateMessageClient<runtime.Types.Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the PrivateConversation model
 */
export interface PrivateConversationFieldRefs {
  readonly id: Prisma.FieldRef<"PrivateConversation", 'String'>
  readonly initiatorId: Prisma.FieldRef<"PrivateConversation", 'String'>
  readonly receiverId: Prisma.FieldRef<"PrivateConversation", 'String'>
  readonly lastMessageId: Prisma.FieldRef<"PrivateConversation", 'String'>
  readonly status: Prisma.FieldRef<"PrivateConversation", 'ConversationStatus'>
  readonly createdAt: Prisma.FieldRef<"PrivateConversation", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"PrivateConversation", 'DateTime'>
}
    

// Custom InputTypes
/**
 * PrivateConversation findUnique
 */
export type PrivateConversationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
  /**
   * Filter, which PrivateConversation to fetch.
   */
  where: Prisma.PrivateConversationWhereUniqueInput
}

/**
 * PrivateConversation findUniqueOrThrow
 */
export type PrivateConversationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
  /**
   * Filter, which PrivateConversation to fetch.
   */
  where: Prisma.PrivateConversationWhereUniqueInput
}

/**
 * PrivateConversation findFirst
 */
export type PrivateConversationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
  /**
   * Filter, which PrivateConversation to fetch.
   */
  where?: Prisma.PrivateConversationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PrivateConversations to fetch.
   */
  orderBy?: Prisma.PrivateConversationOrderByWithRelationInput | Prisma.PrivateConversationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PrivateConversations.
   */
  cursor?: Prisma.PrivateConversationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PrivateConversations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PrivateConversations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PrivateConversations.
   */
  distinct?: Prisma.PrivateConversationScalarFieldEnum | Prisma.PrivateConversationScalarFieldEnum[]
}

/**
 * PrivateConversation findFirstOrThrow
 */
export type PrivateConversationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
  /**
   * Filter, which PrivateConversation to fetch.
   */
  where?: Prisma.PrivateConversationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PrivateConversations to fetch.
   */
  orderBy?: Prisma.PrivateConversationOrderByWithRelationInput | Prisma.PrivateConversationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PrivateConversations.
   */
  cursor?: Prisma.PrivateConversationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PrivateConversations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PrivateConversations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PrivateConversations.
   */
  distinct?: Prisma.PrivateConversationScalarFieldEnum | Prisma.PrivateConversationScalarFieldEnum[]
}

/**
 * PrivateConversation findMany
 */
export type PrivateConversationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
  /**
   * Filter, which PrivateConversations to fetch.
   */
  where?: Prisma.PrivateConversationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PrivateConversations to fetch.
   */
  orderBy?: Prisma.PrivateConversationOrderByWithRelationInput | Prisma.PrivateConversationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing PrivateConversations.
   */
  cursor?: Prisma.PrivateConversationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PrivateConversations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PrivateConversations.
   */
  skip?: number
  distinct?: Prisma.PrivateConversationScalarFieldEnum | Prisma.PrivateConversationScalarFieldEnum[]
}

/**
 * PrivateConversation create
 */
export type PrivateConversationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
  /**
   * The data needed to create a PrivateConversation.
   */
  data: Prisma.XOR<Prisma.PrivateConversationCreateInput, Prisma.PrivateConversationUncheckedCreateInput>
}

/**
 * PrivateConversation createMany
 */
export type PrivateConversationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many PrivateConversations.
   */
  data: Prisma.PrivateConversationCreateManyInput | Prisma.PrivateConversationCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * PrivateConversation createManyAndReturn
 */
export type PrivateConversationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * The data used to create many PrivateConversations.
   */
  data: Prisma.PrivateConversationCreateManyInput | Prisma.PrivateConversationCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * PrivateConversation update
 */
export type PrivateConversationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
  /**
   * The data needed to update a PrivateConversation.
   */
  data: Prisma.XOR<Prisma.PrivateConversationUpdateInput, Prisma.PrivateConversationUncheckedUpdateInput>
  /**
   * Choose, which PrivateConversation to update.
   */
  where: Prisma.PrivateConversationWhereUniqueInput
}

/**
 * PrivateConversation updateMany
 */
export type PrivateConversationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update PrivateConversations.
   */
  data: Prisma.XOR<Prisma.PrivateConversationUpdateManyMutationInput, Prisma.PrivateConversationUncheckedUpdateManyInput>
  /**
   * Filter which PrivateConversations to update
   */
  where?: Prisma.PrivateConversationWhereInput
  /**
   * Limit how many PrivateConversations to update.
   */
  limit?: number
}

/**
 * PrivateConversation updateManyAndReturn
 */
export type PrivateConversationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * The data used to update PrivateConversations.
   */
  data: Prisma.XOR<Prisma.PrivateConversationUpdateManyMutationInput, Prisma.PrivateConversationUncheckedUpdateManyInput>
  /**
   * Filter which PrivateConversations to update
   */
  where?: Prisma.PrivateConversationWhereInput
  /**
   * Limit how many PrivateConversations to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * PrivateConversation upsert
 */
export type PrivateConversationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
  /**
   * The filter to search for the PrivateConversation to update in case it exists.
   */
  where: Prisma.PrivateConversationWhereUniqueInput
  /**
   * In case the PrivateConversation found by the `where` argument doesn't exist, create a new PrivateConversation with this data.
   */
  create: Prisma.XOR<Prisma.PrivateConversationCreateInput, Prisma.PrivateConversationUncheckedCreateInput>
  /**
   * In case the PrivateConversation was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.PrivateConversationUpdateInput, Prisma.PrivateConversationUncheckedUpdateInput>
}

/**
 * PrivateConversation delete
 */
export type PrivateConversationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
  /**
   * Filter which PrivateConversation to delete.
   */
  where: Prisma.PrivateConversationWhereUniqueInput
}

/**
 * PrivateConversation deleteMany
 */
export type PrivateConversationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PrivateConversations to delete
   */
  where?: Prisma.PrivateConversationWhereInput
  /**
   * Limit how many PrivateConversations to delete.
   */
  limit?: number
}

/**
 * PrivateConversation.messages
 */
export type PrivateConversation$messagesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateMessage
   */
  select?: Prisma.PrivateMessageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateMessage
   */
  omit?: Prisma.PrivateMessageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateMessageInclude<ExtArgs> | null
  where?: Prisma.PrivateMessageWhereInput
  orderBy?: Prisma.PrivateMessageOrderByWithRelationInput | Prisma.PrivateMessageOrderByWithRelationInput[]
  cursor?: Prisma.PrivateMessageWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.PrivateMessageScalarFieldEnum | Prisma.PrivateMessageScalarFieldEnum[]
}

/**
 * PrivateConversation.calls
 */
export type PrivateConversation$callsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateCall
   */
  select?: Prisma.PrivateCallSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateCall
   */
  omit?: Prisma.PrivateCallOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateCallInclude<ExtArgs> | null
  where?: Prisma.PrivateCallWhereInput
  orderBy?: Prisma.PrivateCallOrderByWithRelationInput | Prisma.PrivateCallOrderByWithRelationInput[]
  cursor?: Prisma.PrivateCallWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.PrivateCallScalarFieldEnum | Prisma.PrivateCallScalarFieldEnum[]
}

/**
 * PrivateConversation.lastMessage
 */
export type PrivateConversation$lastMessageArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateMessage
   */
  select?: Prisma.PrivateMessageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateMessage
   */
  omit?: Prisma.PrivateMessageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateMessageInclude<ExtArgs> | null
  where?: Prisma.PrivateMessageWhereInput
}

/**
 * PrivateConversation without action
 */
export type PrivateConversationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PrivateConversation
   */
  select?: Prisma.PrivateConversationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PrivateConversation
   */
  omit?: Prisma.PrivateConversationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PrivateConversationInclude<ExtArgs> | null
}
